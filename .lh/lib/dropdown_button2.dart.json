{
    "sourceFile": "lib/dropdown_button2.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1720994227249,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1720994227249,
            "name": "Commit-0",
            "content": "/*\n * Created by AHMED ELSAYED on 30 Nov 2021.\n * email: ahmedelsaayid@gmail.com\n * Edits made on original source code by Flutter.\n * Copyright 2014 The Flutter Authors. All rights reserved.\n*/\n\nimport 'dart:math' as math;\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/services.dart';\n\npart 'src/enums.dart';\n\npart 'src/utils.dart';\n\nconst Duration _kDropdownMenuDuration = Duration(milliseconds: 300);\nconst double _kMenuItemHeight = kMinInteractiveDimension;\nconst double _kDenseButtonHeight = 24.0;\nconst EdgeInsets _kMenuItemPadding = EdgeInsets.symmetric(horizontal: 16.0);\nconst EdgeInsetsGeometry _kAlignedButtonPadding =\n    EdgeInsetsDirectional.only(start: 16.0, end: 4.0);\nconst EdgeInsets _kUnalignedButtonPadding = EdgeInsets.zero;\n\ntypedef _OnMenuStateChangeFn = void Function(bool isOpen);\n\ntypedef _SearchMatchFn<T> = bool Function(\n  DropdownMenuItem<T> item,\n  String searchValue,\n);\n\n_SearchMatchFn _defaultSearchMatchFn = (item, searchValue) =>\n    item.value.toString().toLowerCase().contains(searchValue.toLowerCase());\n\nclass _DropdownMenuPainter extends CustomPainter {\n  _DropdownMenuPainter({\n    this.color,\n    this.elevation,\n    this.selectedIndex,\n    required this.resize,\n    required this.itemHeight,\n    this.dropdownDecoration,\n  })  : _painter = dropdownDecoration\n                ?.copyWith(\n                  color: dropdownDecoration.color ?? color,\n                  boxShadow: dropdownDecoration.boxShadow ??\n                      kElevationToShadow[elevation],\n                )\n                .createBoxPainter() ??\n            BoxDecoration(\n              // If you add an image here, you must provide a real\n              // configuration in the paint() function and you must provide some sort\n              // of onChanged callback here.\n              color: color,\n              borderRadius: const BorderRadius.all(Radius.circular(2.0)),\n              boxShadow: kElevationToShadow[elevation],\n            ).createBoxPainter(),\n        super(repaint: resize);\n\n  final Color? color;\n  final int? elevation;\n  final int? selectedIndex;\n  final Animation<double> resize;\n  final double itemHeight;\n  final BoxDecoration? dropdownDecoration;\n\n  final BoxPainter _painter;\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final Tween<double> top = Tween<double>(\n      //Begin at 0.0 instead of selectedItemOffset so that the menu open animation\n      //always start from top to bottom instead of starting from the selected item\n      begin: 0.0,\n      end: 0.0,\n    );\n\n    final Tween<double> bottom = Tween<double>(\n      begin: _clampDouble(top.begin! + itemHeight,\n          math.min(itemHeight, size.height), size.height),\n      end: size.height,\n    );\n\n    final Rect rect = Rect.fromLTRB(\n        0.0, top.evaluate(resize), size.width, bottom.evaluate(resize));\n\n    _painter.paint(canvas, rect.topLeft, ImageConfiguration(size: rect.size));\n  }\n\n  @override\n  bool shouldRepaint(_DropdownMenuPainter oldPainter) {\n    return oldPainter.color != color ||\n        oldPainter.elevation != elevation ||\n        oldPainter.selectedIndex != selectedIndex ||\n        oldPainter.dropdownDecoration != dropdownDecoration ||\n        oldPainter.itemHeight != itemHeight ||\n        oldPainter.resize != resize;\n  }\n}\n\n// The widget that is the button wrapping the menu items.\nclass _DropdownMenuItemButton<T> extends StatefulWidget {\n  const _DropdownMenuItemButton({\n    super.key,\n    this.padding,\n    required this.route,\n    required this.buttonRect,\n    required this.constraints,\n    required this.itemIndex,\n    required this.enableFeedback,\n    this.itemSplashColor,\n    this.itemHighlightColor,\n    this.customItemsHeights,\n  });\n\n  final _DropdownRoute<T> route;\n  final EdgeInsets? padding;\n  final Rect buttonRect;\n  final BoxConstraints constraints;\n  final int itemIndex;\n  final bool enableFeedback;\n  final Color? itemSplashColor;\n  final Color? itemHighlightColor;\n  final List<double>? customItemsHeights;\n\n  @override\n  _DropdownMenuItemButtonState<T> createState() =>\n      _DropdownMenuItemButtonState<T>();\n}\n\nclass _DropdownMenuItemButtonState<T>\n    extends State<_DropdownMenuItemButton<T>> {\n  void _handleFocusChange(bool focused) {\n    final bool inTraditionalMode;\n    switch (FocusManager.instance.highlightMode) {\n      case FocusHighlightMode.touch:\n        inTraditionalMode = false;\n        break;\n      case FocusHighlightMode.traditional:\n        inTraditionalMode = true;\n        break;\n    }\n\n    if (focused && inTraditionalMode) {\n      final _MenuLimits menuLimits = widget.route.getMenuLimits(\n        widget.buttonRect,\n        widget.constraints.maxHeight,\n        widget.itemIndex,\n      );\n      widget.route.scrollController!.animateTo(\n        menuLimits.scrollOffset,\n        curve: Curves.easeInOut,\n        duration: const Duration(milliseconds: 100),\n      );\n    }\n  }\n\n  void _handleOnTap() {\n    final DropdownMenuItem<T> dropdownMenuItem =\n        widget.route.items[widget.itemIndex].item!;\n\n    dropdownMenuItem.onTap?.call();\n\n    Navigator.pop(\n      context,\n      _DropdownRouteResult<T>(dropdownMenuItem.value),\n    );\n  }\n\n  static const Map<ShortcutActivator, Intent> _webShortcuts =\n      <ShortcutActivator, Intent>{\n    // On the web, up/down don't change focus, *except* in a <select>\n    // element, which is what a dropdown emulates.\n    SingleActivator(LogicalKeyboardKey.arrowDown):\n        DirectionalFocusIntent(TraversalDirection.down),\n    SingleActivator(LogicalKeyboardKey.arrowUp):\n        DirectionalFocusIntent(TraversalDirection.up),\n  };\n\n  @override\n  Widget build(BuildContext context) {\n    final DropdownMenuItem<T> dropdownMenuItem =\n        widget.route.items[widget.itemIndex].item!;\n    final double unit = 0.5 / (widget.route.items.length + 1.5);\n    final double start =\n        _clampDouble(0.5 + (widget.itemIndex + 1) * unit, 0.0, 1.0);\n    final double end = _clampDouble(start + 1.5 * unit, 0.0, 1.0);\n    final CurvedAnimation opacity = CurvedAnimation(\n        parent: widget.route.animation!, curve: Interval(start, end));\n\n    Widget child = Container(\n      padding: widget.padding,\n      height: widget.customItemsHeights == null\n          ? widget.route.itemHeight\n          : widget.customItemsHeights![widget.itemIndex],\n      child: widget.route.items[widget.itemIndex],\n    );\n    // An [InkWell] is added to the item only if it is enabled\n    // isNoSelectedItem to avoid first item highlight when no item selected\n    if (dropdownMenuItem.enabled) {\n      final _isSelectedItem = !widget.route.isNoSelectedItem &&\n          widget.itemIndex == widget.route.selectedIndex;\n      child = InkWell(\n        autofocus: _isSelectedItem,\n        enableFeedback: widget.enableFeedback,\n        onTap: _handleOnTap,\n        onFocusChange: _handleFocusChange,\n        splashColor: widget.itemSplashColor,\n        highlightColor: widget.itemHighlightColor,\n        child: Container(\n          color:\n              _isSelectedItem ? widget.route.selectedItemHighlightColor : null,\n          child: child,\n        ),\n      );\n    }\n    child = FadeTransition(opacity: opacity, child: child);\n    if (kIsWeb && dropdownMenuItem.enabled) {\n      child = Shortcuts(\n        shortcuts: _webShortcuts,\n        child: child,\n      );\n    }\n    return child;\n  }\n}\n\nclass _DropdownMenu<T> extends StatefulWidget {\n  const _DropdownMenu({\n    super.key,\n    this.padding,\n    required this.route,\n    required this.buttonRect,\n    required this.constraints,\n    required this.enableFeedback,\n    required this.itemHeight,\n    this.dropdownDecoration,\n    this.dropdownPadding,\n    this.dropdownScrollPadding,\n    this.scrollbarRadius,\n    this.scrollbarThickness,\n    this.scrollbarAlwaysShow,\n    required this.offset,\n    this.itemSplashColor,\n    this.itemHighlightColor,\n    this.customItemsHeights,\n    this.searchController,\n    this.searchInnerWidget,\n    this.searchMatchFn,\n  });\n\n  final _DropdownRoute<T> route;\n  final EdgeInsets? padding;\n  final Rect buttonRect;\n  final BoxConstraints constraints;\n  final bool enableFeedback;\n  final double itemHeight;\n  final BoxDecoration? dropdownDecoration;\n  final EdgeInsetsGeometry? dropdownPadding;\n  final EdgeInsetsGeometry? dropdownScrollPadding;\n  final Radius? scrollbarRadius;\n  final double? scrollbarThickness;\n  final bool? scrollbarAlwaysShow;\n  final Offset offset;\n  final Color? itemSplashColor;\n  final Color? itemHighlightColor;\n  final List<double>? customItemsHeights;\n  final TextEditingController? searchController;\n  final Widget? searchInnerWidget;\n  final _SearchMatchFn<T>? searchMatchFn;\n\n  @override\n  _DropdownMenuState<T> createState() => _DropdownMenuState<T>();\n}\n\nclass _DropdownMenuState<T> extends State<_DropdownMenu<T>> {\n  late CurvedAnimation _fadeOpacity;\n  late CurvedAnimation _resize;\n  late List<Widget> _children;\n  late _SearchMatchFn<T> _searchMatchFn;\n\n  @override\n  void initState() {\n    super.initState();\n    // We need to hold these animations as state because of their curve\n    // direction. When the route's animation reverses, if we were to recreate\n    // the CurvedAnimation objects in build, we'd lose\n    // CurvedAnimation._curveDirection.\n    _fadeOpacity = CurvedAnimation(\n      parent: widget.route.animation!,\n      curve: const Interval(0.0, 0.25),\n      reverseCurve: const Interval(0.75, 1.0),\n    );\n    _resize = CurvedAnimation(\n      parent: widget.route.animation!,\n      curve: const Interval(0.25, 0.5),\n      reverseCurve: const Threshold(0.0),\n    );\n    //If searchController is null, then it'll perform as a normal dropdown\n    //and search functions will not be executed.\n    if (widget.searchController == null) {\n      _children = <Widget>[\n        for (int index = 0; index < widget.route.items.length; ++index)\n          _DropdownMenuItemButton<T>(\n            route: widget.route,\n            padding: widget.padding,\n            buttonRect: widget.buttonRect,\n            constraints: widget.constraints,\n            itemIndex: index,\n            enableFeedback: widget.enableFeedback,\n            itemSplashColor: widget.itemSplashColor,\n            itemHighlightColor: widget.itemHighlightColor,\n            customItemsHeights: widget.customItemsHeights,\n          ),\n      ];\n    } else {\n      _searchMatchFn = widget.searchMatchFn ?? _defaultSearchMatchFn;\n      _children = _getSearchItems();\n      // Add listener to searchController (if it's used) to update the shown items.\n      widget.searchController?.addListener(_updateSearchItems);\n    }\n  }\n\n  void _updateSearchItems() {\n    _children = _getSearchItems();\n    setState(() {});\n  }\n\n  List<Widget> _getSearchItems() {\n    return <Widget>[\n      for (int index = 0; index < widget.route.items.length; ++index)\n        if (_searchMatchFn(\n            widget.route.items[index].item!, widget.searchController!.text))\n          _DropdownMenuItemButton<T>(\n            route: widget.route,\n            padding: widget.padding,\n            buttonRect: widget.buttonRect,\n            constraints: widget.constraints,\n            itemIndex: index,\n            enableFeedback: widget.enableFeedback,\n            itemSplashColor: widget.itemSplashColor,\n            itemHighlightColor: widget.itemHighlightColor,\n            customItemsHeights: widget.customItemsHeights,\n          ),\n    ];\n  }\n\n  @override\n  void dispose() {\n    _fadeOpacity.dispose();\n    _resize.dispose();\n    widget.searchController?.removeListener(_updateSearchItems);\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // The menu is shown in three stages (unit timing in brackets):\n    // [0s - 0.25s] - Fade in a rect-sized menu container with the selected item.\n    // [0.25s - 0.5s] - Grow the otherwise empty menu container from the center\n    //   until it's big enough for as many items as we're going to show.\n    // [0.5s - 1.0s] Fade in the remaining visible items from top to bottom.\n    //\n    // When the menu is dismissed we just fade the entire thing out\n    // in the first 0.25s.\n    assert(debugCheckHasMaterialLocalizations(context));\n    final MaterialLocalizations localizations =\n        MaterialLocalizations.of(context);\n    final _DropdownRoute<T> route = widget.route;\n\n    return FadeTransition(\n      opacity: _fadeOpacity,\n      child: CustomPaint(\n        painter: _DropdownMenuPainter(\n          color: Theme.of(context).canvasColor,\n          elevation: route.elevation,\n          selectedIndex: route.selectedIndex,\n          resize: _resize,\n          itemHeight: widget.itemHeight,\n          dropdownDecoration: widget.dropdownDecoration,\n        ),\n        child: Semantics(\n          scopesRoute: true,\n          namesRoute: true,\n          explicitChildNodes: true,\n          label: localizations.popupMenuLabel,\n          child: ClipRRect(\n            //Prevent scrollbar, ripple effect & items from going beyond border boundaries when scrolling.\n            clipBehavior: widget.dropdownDecoration?.borderRadius != null\n                ? Clip.antiAlias\n                : Clip.none,\n            borderRadius: widget.dropdownDecoration?.borderRadius\n                    ?.resolve(Directionality.of(context)) ??\n                BorderRadius.zero,\n            child: Material(\n              type: MaterialType.transparency,\n              textStyle: route.style,\n              child: Column(\n                mainAxisSize: MainAxisSize.min,\n                children: [\n                  if (widget.searchInnerWidget != null)\n                    widget.searchInnerWidget!,\n                  Flexible(\n                    child: Padding(\n                      padding: widget.dropdownScrollPadding ?? EdgeInsets.zero,\n                      child: ScrollConfiguration(\n                        // Dropdown menus should never overscroll or display an overscroll indicator.\n                        // Scrollbars are built-in below.\n                        // Platform must use Theme and ScrollPhysics must be Clamping.\n                        behavior: ScrollConfiguration.of(context).copyWith(\n                          scrollbars: false,\n                          overscroll: false,\n                          physics: const ClampingScrollPhysics(),\n                          platform: Theme.of(context).platform,\n                        ),\n                        child: PrimaryScrollController(\n                          controller: widget.route.scrollController!,\n                          child: Scrollbar(\n                            radius: widget.scrollbarRadius,\n                            thickness: widget.scrollbarThickness,\n                            thumbVisibility: widget.scrollbarAlwaysShow,\n                            child: ListView(\n                              // Ensure this always inherits the PrimaryScrollController\n                              primary: true,\n                              padding: widget.dropdownPadding ??\n                                  kMaterialListPadding,\n                              shrinkWrap: true,\n                              children: _children,\n                            ),\n                          ),\n                        ),\n                      ),\n                    ),\n                  ),\n                ],\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nclass _DropdownMenuRouteLayout<T> extends SingleChildLayoutDelegate {\n  _DropdownMenuRouteLayout({\n    required this.buttonRect,\n    required this.availableHeight,\n    required this.route,\n    required this.dropdownDirection,\n    required this.textDirection,\n    required this.itemHeight,\n    this.itemWidth,\n    required this.offset,\n  });\n\n  final Rect buttonRect;\n  final double availableHeight;\n  final _DropdownRoute<T> route;\n  final DropdownDirection dropdownDirection;\n  final TextDirection? textDirection;\n  final double itemHeight;\n  final double? itemWidth;\n  final Offset offset;\n\n  @override\n  BoxConstraints getConstraintsForChild(BoxConstraints constraints) {\n    // The maximum height of a simple menu should be one or more rows less than\n    // the view height. This ensures a tappable area outside of the simple menu\n    // with which to dismiss the menu.\n    //   -- https://material.io/design/components/menus.html#usage\n    double maxHeight = math.max(0.0, availableHeight - 2 * itemHeight);\n    if (route.menuMaxHeight != null && route.menuMaxHeight! <= maxHeight) {\n      maxHeight = route.menuMaxHeight!;\n    }\n    // The width of a menu should be at most the view width. This ensures that\n    // the menu does not extend past the left and right edges of the screen.\n    final double width =\n        math.min(constraints.maxWidth, itemWidth ?? buttonRect.width);\n    return BoxConstraints(\n      minWidth: width,\n      maxWidth: width,\n      maxHeight: maxHeight,\n    );\n  }\n\n  @override\n  Offset getPositionForChild(Size size, Size childSize) {\n    final _MenuLimits menuLimits =\n        route.getMenuLimits(buttonRect, availableHeight, route.selectedIndex);\n\n    assert(() {\n      final Rect container = Offset.zero & size;\n      if (container.intersect(buttonRect) == buttonRect) {\n        // If the button was entirely on-screen, then verify\n        // that the menu is also on-screen.\n        // If the button was a bit off-screen, then, oh well.\n        assert(menuLimits.top >= 0.0);\n        assert(menuLimits.top + menuLimits.height <= size.height);\n      }\n      return true;\n    }());\n    assert(textDirection != null);\n    final double left;\n\n    switch (dropdownDirection) {\n      case DropdownDirection.textDirection:\n        switch (textDirection!) {\n          case TextDirection.rtl:\n            left = _clampDouble(\n              buttonRect.right - childSize.width + offset.dx,\n              0.0,\n              size.width - childSize.width,\n            );\n            break;\n          case TextDirection.ltr:\n            left = _clampDouble(\n              buttonRect.left + offset.dx,\n              0.0,\n              size.width - childSize.width,\n            );\n            break;\n        }\n        break;\n      case DropdownDirection.right:\n        left = _clampDouble(\n          buttonRect.left + offset.dx,\n          0.0,\n          size.width - childSize.width,\n        );\n        break;\n      case DropdownDirection.left:\n        left = _clampDouble(\n          buttonRect.right - childSize.width + offset.dx,\n          0.0,\n          size.width - childSize.width,\n        );\n        break;\n    }\n\n    return Offset(left, menuLimits.top);\n  }\n\n  @override\n  bool shouldRelayout(_DropdownMenuRouteLayout<T> oldDelegate) {\n    return buttonRect != oldDelegate.buttonRect ||\n        textDirection != oldDelegate.textDirection;\n  }\n}\n\n// We box the return value so that the return value can be null. Otherwise,\n// canceling the route (which returns null) would get confused with actually\n// returning a real null value.\n@immutable\nclass _DropdownRouteResult<T> {\n  const _DropdownRouteResult(this.result);\n\n  final T? result;\n\n  @override\n  bool operator ==(Object other) {\n    return other is _DropdownRouteResult<T> && other.result == result;\n  }\n\n  @override\n  int get hashCode => result.hashCode;\n}\n\nclass _MenuLimits {\n  const _MenuLimits(this.top, this.bottom, this.height, this.scrollOffset);\n\n  final double top;\n  final double bottom;\n  final double height;\n  final double scrollOffset;\n}\n\nclass _DropdownRoute<T> extends PopupRoute<_DropdownRouteResult<T>> {\n  _DropdownRoute({\n    required this.items,\n    required this.padding,\n    required this.buttonRect,\n    required this.selectedIndex,\n    required this.isNoSelectedItem,\n    this.selectedItemHighlightColor,\n    this.elevation = 8,\n    required this.capturedThemes,\n    required this.style,\n    required this.barrierDismissible,\n    this.barrierColor,\n    this.barrierLabel,\n    required this.enableFeedback,\n    required this.itemHeight,\n    this.itemWidth,\n    this.menuMaxHeight,\n    this.dropdownDecoration,\n    this.dropdownPadding,\n    this.dropdownScrollPadding,\n    required this.dropdownDirection,\n    this.scrollbarRadius,\n    this.scrollbarThickness,\n    this.scrollbarAlwaysShow,\n    required this.offset,\n    required this.showAboveButton,\n    this.itemSplashColor,\n    this.itemHighlightColor,\n    this.customItemsHeights,\n    this.searchController,\n    this.searchInnerWidget,\n    this.searchInnerWidgetHeight,\n    this.searchMatchFn,\n  }) : itemHeights =\n            customItemsHeights ?? List<double>.filled(items.length, itemHeight);\n\n  final List<_MenuItem<T>> items;\n  final EdgeInsetsGeometry padding;\n  final ValueNotifier<Rect?> buttonRect;\n  final int selectedIndex;\n  final bool isNoSelectedItem;\n  final Color? selectedItemHighlightColor;\n  final int elevation;\n  final CapturedThemes capturedThemes;\n  final TextStyle style;\n  final bool enableFeedback;\n  final double itemHeight;\n  final double? itemWidth;\n  final double? menuMaxHeight;\n  final BoxDecoration? dropdownDecoration;\n  final EdgeInsetsGeometry? dropdownPadding;\n  final EdgeInsetsGeometry? dropdownScrollPadding;\n  final DropdownDirection dropdownDirection;\n  final Radius? scrollbarRadius;\n  final double? scrollbarThickness;\n  final bool? scrollbarAlwaysShow;\n  final Offset offset;\n  final bool showAboveButton;\n  final Color? itemSplashColor;\n  final Color? itemHighlightColor;\n  final List<double>? customItemsHeights;\n  final TextEditingController? searchController;\n  final Widget? searchInnerWidget;\n  final double? searchInnerWidgetHeight;\n  final _SearchMatchFn<T>? searchMatchFn;\n\n  final List<double> itemHeights;\n  ScrollController? scrollController;\n\n  @override\n  Duration get transitionDuration => _kDropdownMenuDuration;\n\n  @override\n  final bool barrierDismissible;\n\n  @override\n  final Color? barrierColor;\n\n  @override\n  final String? barrierLabel;\n\n  @override\n  Widget buildPage(BuildContext context, Animation<double> animation,\n      Animation<double> secondaryAnimation) {\n    return LayoutBuilder(\n      builder: (BuildContext context, BoxConstraints constraints) {\n        //Exclude BottomInset from maxHeight to avoid overlapping menu items\n        //with keyboard when using searchable dropdown.\n        //This will ensure menu is drawn in the actual available height.\n        final actualConstraints = constraints.copyWith(\n            maxHeight: constraints.maxHeight -\n                MediaQuery.of(context).viewInsets.bottom);\n        return ValueListenableBuilder<Rect?>(\n          valueListenable: buttonRect,\n          builder: (context, rect, _) {\n            return _DropdownRoutePage<T>(\n              route: this,\n              constraints: actualConstraints,\n              padding: padding,\n              buttonRect: rect!,\n              selectedIndex: selectedIndex,\n              elevation: elevation,\n              capturedThemes: capturedThemes,\n              style: style,\n              enableFeedback: enableFeedback,\n              dropdownDecoration: dropdownDecoration,\n              dropdownPadding: dropdownPadding,\n              dropdownScrollPadding: dropdownScrollPadding,\n              dropdownDirection: dropdownDirection,\n              menuMaxHeight: menuMaxHeight,\n              itemHeight: itemHeight,\n              itemWidth: itemWidth,\n              scrollbarRadius: scrollbarRadius,\n              scrollbarThickness: scrollbarThickness,\n              scrollbarAlwaysShow: scrollbarAlwaysShow,\n              offset: offset,\n              itemSplashColor: itemSplashColor,\n              itemHighlightColor: itemHighlightColor,\n              customItemsHeights: customItemsHeights,\n              searchController: searchController,\n              searchInnerWidget: searchInnerWidget,\n              searchMatchFn: searchMatchFn,\n            );\n          },\n        );\n      },\n    );\n  }\n\n  void _dismiss() {\n    if (isActive) {\n      navigator?.removeRoute(this);\n    }\n  }\n\n  double getItemOffset(int index, double paddingTop) {\n    double offset = paddingTop;\n    if (items.isNotEmpty && index > 0) {\n      assert(items.length == itemHeights.length);\n      offset += itemHeights\n          .sublist(0, index)\n          .reduce((double total, double height) => total + height);\n    }\n    return offset;\n  }\n\n  // Returns the vertical extent of the menu and the initial scrollOffset\n  // for the ListView that contains the menu items. The vertical center of the\n  // selected item is aligned with the button's vertical center, as far as\n  // that's possible given availableHeight.\n  _MenuLimits getMenuLimits(\n      Rect buttonRect, double availableHeight, int index) {\n    double computedMaxHeight = availableHeight - 2.0 * itemHeight;\n    if (menuMaxHeight != null) {\n      computedMaxHeight = math.min(computedMaxHeight, menuMaxHeight!);\n    }\n    final double buttonTop = buttonRect.top;\n    final double buttonBottom = math.min(buttonRect.bottom, availableHeight);\n    double paddingTop = dropdownPadding != null\n        ? dropdownPadding!.resolve(null).top\n        : kMaterialListPadding.top;\n    final double selectedItemOffset = getItemOffset(index, paddingTop);\n\n    final double innerWidgetHeight = searchInnerWidgetHeight ?? 0.0;\n\n    // If the button is placed on the bottom or top of the screen, its top or\n    // bottom may be less than itemHeight from the edge of the screen.\n    // In this case, we want to change the menu limits to align with the top\n    // or bottom edge of the button.\n    final double topLimit = math.min(itemHeight, buttonTop);\n    final double bottomLimit = math.max(availableHeight, buttonBottom);\n    double menuTop =\n        showAboveButton ? buttonTop - offset.dy : buttonBottom - offset.dy;\n    double preferredMenuHeight =\n        dropdownPadding?.vertical ?? kMaterialListPadding.vertical;\n    preferredMenuHeight += innerWidgetHeight;\n    if (items.isNotEmpty) {\n      preferredMenuHeight +=\n          itemHeights.reduce((double total, double height) => total + height);\n    }\n\n    // If there are too many elements in the menu, we need to shrink it down\n    // so it is at most the computedMaxHeight.\n    final double menuHeight = math.min(computedMaxHeight, preferredMenuHeight);\n    double menuBottom = menuTop + menuHeight;\n\n    // If the computed top or bottom of the menu are outside of the range\n    // specified, we need to bring them into range. If the item height is larger\n    // than the button height and the button is at the very bottom or top of the\n    // screen, the menu will be aligned with the bottom or top of the button\n    // respectively.\n    if (menuTop < topLimit) {\n      menuTop = math.min(buttonTop, topLimit);\n      menuBottom = menuTop + menuHeight;\n    }\n\n    if (menuBottom > bottomLimit) {\n      menuBottom = math.max(buttonBottom, bottomLimit);\n      menuTop = menuBottom - menuHeight;\n    }\n\n    double scrollOffset = 0;\n    // If all of the menu items will not fit within availableHeight then\n    // compute the scroll offset that will line the selected menu item up\n    // with the select item. This is only done when the menu is first\n    // shown - subsequently we leave the scroll offset where the user left\n    // it. This scroll offset is only accurate for fixed height menu items\n    // (the default).\n    if (preferredMenuHeight > computedMaxHeight) {\n      //menuHeight & preferredMenuHeight without innerWidget's Height\n      final menuNetHeight = menuHeight - innerWidgetHeight;\n      final preferredMenuNetHeight = preferredMenuHeight - innerWidgetHeight;\n      // The offset should be zero if the selected item is in view at the beginning\n      // of the menu. Otherwise, the scroll offset should center the item if possible.\n      scrollOffset = math.max(\n          0.0,\n          selectedItemOffset -\n              (menuNetHeight / 2) +\n              (itemHeights[selectedIndex] / 2));\n      // If the selected item's scroll offset is greater than the maximum scroll offset,\n      // set it instead to the maximum allowed scroll offset.\n      final maxScrollOffset = preferredMenuNetHeight - menuNetHeight;\n      scrollOffset = math.min(scrollOffset, maxScrollOffset);\n    }\n\n    assert((menuBottom - menuTop - menuHeight).abs() < precisionErrorTolerance);\n    return _MenuLimits(menuTop, menuBottom, menuHeight, scrollOffset);\n  }\n}\n\nclass _DropdownRoutePage<T> extends StatelessWidget {\n  const _DropdownRoutePage({\n    super.key,\n    required this.route,\n    required this.constraints,\n    required this.padding,\n    required this.buttonRect,\n    required this.selectedIndex,\n    this.elevation = 8,\n    required this.capturedThemes,\n    this.style,\n    required this.enableFeedback,\n    this.dropdownDecoration,\n    this.dropdownPadding,\n    this.dropdownScrollPadding,\n    required this.dropdownDirection,\n    this.menuMaxHeight,\n    required this.itemHeight,\n    this.itemWidth,\n    this.scrollbarRadius,\n    this.scrollbarThickness,\n    this.scrollbarAlwaysShow,\n    required this.offset,\n    this.itemSplashColor,\n    this.itemHighlightColor,\n    this.customItemsHeights,\n    this.searchController,\n    this.searchInnerWidget,\n    this.searchMatchFn,\n  });\n\n  final _DropdownRoute<T> route;\n  final BoxConstraints constraints;\n  final EdgeInsetsGeometry padding;\n  final Rect buttonRect;\n  final int selectedIndex;\n  final int elevation;\n  final CapturedThemes capturedThemes;\n  final TextStyle? style;\n  final bool enableFeedback;\n  final BoxDecoration? dropdownDecoration;\n  final EdgeInsetsGeometry? dropdownPadding;\n  final EdgeInsetsGeometry? dropdownScrollPadding;\n  final DropdownDirection dropdownDirection;\n  final double? menuMaxHeight;\n  final double itemHeight;\n  final double? itemWidth;\n  final Radius? scrollbarRadius;\n  final double? scrollbarThickness;\n  final bool? scrollbarAlwaysShow;\n  final Offset offset;\n  final Color? itemSplashColor;\n  final Color? itemHighlightColor;\n  final List<double>? customItemsHeights;\n  final TextEditingController? searchController;\n  final Widget? searchInnerWidget;\n  final _SearchMatchFn<T>? searchMatchFn;\n\n  @override\n  Widget build(BuildContext context) {\n    assert(debugCheckHasDirectionality(context));\n\n    // Computing the initialScrollOffset now, before the items have been laid\n    // out. This only works if the item heights are effectively fixed, i.e. either\n    // DropdownButton.itemHeight is specified or DropdownButton.itemHeight is null\n    // and all of the items' intrinsic heights are less than kMinInteractiveDimension.\n    // Otherwise the initialScrollOffset is just a rough approximation based on\n    // treating the items as if their heights were all equal to kMinInteractiveDimension.\n    if (route.scrollController == null) {\n      final _MenuLimits menuLimits =\n          route.getMenuLimits(buttonRect, constraints.maxHeight, selectedIndex);\n      route.scrollController =\n          ScrollController(initialScrollOffset: menuLimits.scrollOffset);\n    }\n\n    final TextDirection? textDirection = Directionality.maybeOf(context);\n    final Widget menu = _DropdownMenu<T>(\n      route: route,\n      padding: padding.resolve(textDirection),\n      buttonRect: buttonRect,\n      constraints: constraints,\n      enableFeedback: enableFeedback,\n      itemHeight: itemHeight,\n      dropdownDecoration: dropdownDecoration,\n      dropdownPadding: dropdownPadding,\n      dropdownScrollPadding: dropdownScrollPadding,\n      scrollbarRadius: scrollbarRadius,\n      scrollbarThickness: scrollbarThickness,\n      scrollbarAlwaysShow: scrollbarAlwaysShow,\n      offset: offset,\n      itemSplashColor: itemSplashColor,\n      itemHighlightColor: itemHighlightColor,\n      customItemsHeights: customItemsHeights,\n      searchController: searchController,\n      searchInnerWidget: searchInnerWidget,\n      searchMatchFn: searchMatchFn,\n    );\n\n    return MediaQuery.removePadding(\n      context: context,\n      removeTop: true,\n      removeBottom: true,\n      removeLeft: true,\n      removeRight: true,\n      child: Builder(\n        builder: (BuildContext context) {\n          return CustomSingleChildLayout(\n            delegate: _DropdownMenuRouteLayout<T>(\n              buttonRect: buttonRect,\n              availableHeight: constraints.maxHeight,\n              route: route,\n              dropdownDirection: dropdownDirection,\n              textDirection: textDirection,\n              itemHeight: itemHeight,\n              itemWidth: itemWidth,\n              offset: offset,\n            ),\n            child: capturedThemes.wrap(menu),\n          );\n        },\n      ),\n    );\n  }\n}\n\n// This widget enables _DropdownRoute to look up the sizes of\n// each menu item. These sizes are used to compute the offset of the selected\n// item so that _DropdownRoutePage can align the vertical center of the\n// selected item lines up with the vertical center of the dropdown button,\n// as closely as possible.\nclass _MenuItem<T> extends SingleChildRenderObjectWidget {\n  const _MenuItem({\n    super.key,\n    required this.onLayout,\n    required this.item,\n  }) : super(child: item);\n\n  final ValueChanged<Size> onLayout;\n  final DropdownMenuItem<T>? item;\n\n  @override\n  RenderObject createRenderObject(BuildContext context) {\n    return _RenderMenuItem(onLayout);\n  }\n\n  @override\n  void updateRenderObject(\n      BuildContext context, covariant _RenderMenuItem renderObject) {\n    renderObject.onLayout = onLayout;\n  }\n}\n\nclass _RenderMenuItem extends RenderProxyBox {\n  _RenderMenuItem(this.onLayout, [RenderBox? child]) : super(child);\n\n  ValueChanged<Size> onLayout;\n\n  @override\n  void performLayout() {\n    super.performLayout();\n    onLayout(size);\n  }\n}\n\n// The container widget for a menu item created by a [DropdownButton]. It\n// provides the default configuration for [DropdownMenuItem]s, as well as a\n// [DropdownButton]'s hint and disabledHint widgets.\nclass _DropdownMenuItemContainer extends StatelessWidget {\n  /// Creates an item for a dropdown menu.\n  ///\n  /// The [child] argument is required.\n  const _DropdownMenuItemContainer({\n    Key? key,\n    this.alignment = AlignmentDirectional.centerStart,\n    required this.child,\n  }) : super(key: key);\n\n  /// The widget below this widget in the tree.\n  ///\n  /// Typically a [Text] widget.\n  final Widget child;\n\n  /// Defines how the item is positioned within the container.\n  ///\n  /// This property must not be null. It defaults to [AlignmentDirectional.centerStart].\n  ///\n  /// See also:\n  ///\n  ///  * [Alignment], a class with convenient constants typically used to\n  ///    specify an [AlignmentGeometry].\n  ///  * [AlignmentDirectional], like [Alignment] for specifying alignments\n  ///    relative to text direction.\n  final AlignmentGeometry alignment;\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      constraints: const BoxConstraints(minHeight: _kMenuItemHeight),\n      alignment: alignment,\n      child: child,\n    );\n  }\n}\n\n/// A Material Design button for selecting from a list of items.\n///\n/// A dropdown button lets the user select from a number of items. The button\n/// shows the currently selected item as well as an arrow that opens a menu for\n/// selecting another item.\n///\n/// One ancestor must be a [Material] widget and typically this is\n/// provided by the app's [Scaffold].\n///\n/// The type `T` is the type of the [value] that each dropdown item represents.\n/// All the entries in a given menu must represent values with consistent types.\n/// Typically, an enum is used. Each [DropdownMenuItem] in [items] must be\n/// specialized with that same type argument.\n///\n/// The [onChanged] callback should update a state variable that defines the\n/// dropdown's value. It should also call [State.setState] to rebuild the\n/// dropdown with the new value.\n///\n/// {@tool dartpad}\n/// This sample shows a `DropdownButton` with a large arrow icon,\n/// purple text style, and bold purple underline, whose value is one of \"One\",\n/// \"Two\", \"Free\", or \"Four\".\n///\n/// ![](https://flutter.github.io/assets-for-api-docs/assets/material/dropdown_button.png)\n///\n/// ** See code in examples/api/lib/material/dropdown/dropdown_button.0.dart **\n/// {@end-tool}\n///\n/// If the [onChanged] callback is null or the list of [items] is null\n/// then the dropdown button will be disabled, i.e. its arrow will be\n/// displayed in grey and it will not respond to input. A disabled button\n/// will display the [disabledHint] widget if it is non-null. However, if\n/// [disabledHint] is null and [hint] is non-null, the [hint] widget will\n/// instead be displayed.\n///\n/// Requires one of its ancestors to be a [Material] widget.\n///\n/// See also:\n///\n///  * [DropdownButtonFormField2], which integrates with the [Form] widget.\n///  * [DropdownMenuItem], the class used to represent the [items].\n///  * [DropdownButtonHideUnderline], which prevents its descendant dropdown buttons\n///    from displaying their underlines.\n///  * [ElevatedButton], [TextButton], ordinary buttons that trigger a single action.\n///  * <https://material.io/design/components/menus.html#dropdown-menu>\nclass DropdownButton2<T> extends StatefulWidget {\n  /// Creates a DropdownButton2\n  /// It's customizable DropdownButton with steady dropdown menu and many other features.\n  ///\n  /// The [items] must have distinct values. If [value] isn't null then it\n  /// must be equal to one of the [DropdownMenuItem] values. If [items] or\n  /// [onChanged] is null, the button will be disabled, the down arrow\n  /// will be greyed out.\n  ///\n  /// If [value] is null and the button is enabled, [hint] will be displayed\n  /// if it is non-null.\n  ///\n  /// If [value] is null and the button is disabled, [disabledHint] will be displayed\n  /// if it is non-null. If [disabledHint] is null, then [hint] will be displayed\n  /// if it is non-null.\n  DropdownButton2({\n    super.key,\n    required this.items,\n    this.selectedItemBuilder,\n    this.value,\n    this.hint,\n    this.disabledHint,\n    this.onChanged,\n    this.onMenuStateChange,\n    this.dropdownElevation = 8,\n    this.style,\n    this.underline,\n    this.icon,\n    this.iconOnClick,\n    this.iconDisabledColor,\n    this.iconEnabledColor,\n    this.iconSize = 24.0,\n    this.isDense = false,\n    this.isExpanded = false,\n    this.itemHeight = kMinInteractiveDimension,\n    this.focusColor,\n    this.focusNode,\n    this.autofocus = false,\n    this.dropdownMaxHeight,\n    this.enableFeedback,\n    this.alignment = AlignmentDirectional.centerStart,\n    this.buttonHeight,\n    this.buttonWidth,\n    this.buttonPadding,\n    this.buttonDecoration,\n    this.buttonElevation,\n    this.buttonSplashColor,\n    this.buttonHighlightColor,\n    this.buttonOverlayColor,\n    this.itemPadding,\n    this.itemSplashColor,\n    this.itemHighlightColor,\n    this.dropdownWidth,\n    this.dropdownPadding,\n    this.dropdownScrollPadding,\n    this.dropdownDecoration,\n    this.dropdownDirection = DropdownDirection.textDirection,\n    this.selectedItemHighlightColor,\n    this.scrollbarRadius,\n    this.scrollbarThickness,\n    this.scrollbarAlwaysShow,\n    this.offset,\n    this.customButton,\n    this.customItemsHeights,\n    this.openWithLongPress = false,\n    this.dropdownOverButton = false,\n    this.dropdownFullScreen = false,\n    this.barrierDismissible = true,\n    this.barrierColor,\n    this.barrierLabel,\n    this.searchController,\n    this.searchInnerWidget,\n    this.searchInnerWidgetHeight,\n    this.searchMatchFn,\n    // When adding new arguments, consider adding similar arguments to\n    // DropdownButtonFormField.\n  })  : assert(\n          items == null ||\n              items.isEmpty ||\n              value == null ||\n              items.where((DropdownMenuItem<T> item) {\n                    return item.value == value;\n                  }).length ==\n                  1,\n          \"There should be exactly one item with [DropdownButton]'s value: \"\n          '$value. \\n'\n          'Either zero or 2 or more [DropdownMenuItem]s were detected '\n          'with the same value',\n        ),\n        assert(\n          customItemsHeights == null ||\n              items == null ||\n              items.isEmpty ||\n              customItemsHeights.length == items.length,\n          \"customItemsHeights list should have the same length of items list\",\n        ),\n        assert(\n          (searchInnerWidget == null) == (searchInnerWidgetHeight == null),\n          \"searchInnerWidgetHeight should not be null when using searchInnerWidget\"\n          \"This is necessary to properly determine menu limits and scroll offset\",\n        ),\n        formFieldCallBack = null;\n\n  DropdownButton2._formField({\n    super.key,\n    required this.items,\n    this.selectedItemBuilder,\n    this.value,\n    this.hint,\n    this.disabledHint,\n    required this.onChanged,\n    this.onMenuStateChange,\n    this.dropdownElevation = 8,\n    this.style,\n    this.underline,\n    this.icon,\n    this.iconOnClick,\n    this.iconDisabledColor,\n    this.iconEnabledColor,\n    this.iconSize = 24.0,\n    this.isDense = false,\n    this.isExpanded = false,\n    this.itemHeight = kMinInteractiveDimension,\n    this.focusColor,\n    this.focusNode,\n    this.autofocus = false,\n    this.dropdownMaxHeight,\n    this.enableFeedback,\n    this.alignment = AlignmentDirectional.centerStart,\n    this.buttonHeight,\n    this.buttonWidth,\n    this.buttonPadding,\n    this.buttonDecoration,\n    this.buttonElevation,\n    this.buttonSplashColor,\n    this.buttonHighlightColor,\n    this.buttonOverlayColor,\n    this.itemPadding,\n    this.itemSplashColor,\n    this.itemHighlightColor,\n    this.dropdownWidth,\n    this.dropdownPadding,\n    this.dropdownScrollPadding,\n    this.dropdownDecoration,\n    this.dropdownDirection = DropdownDirection.textDirection,\n    this.selectedItemHighlightColor,\n    this.scrollbarRadius,\n    this.scrollbarThickness,\n    this.scrollbarAlwaysShow,\n    this.offset,\n    this.customButton,\n    this.customItemsHeights,\n    this.openWithLongPress = false,\n    this.dropdownOverButton = false,\n    this.dropdownFullScreen = false,\n    this.barrierDismissible = true,\n    this.barrierColor,\n    this.barrierLabel,\n    this.searchController,\n    this.searchInnerWidget,\n    this.searchInnerWidgetHeight,\n    this.searchMatchFn,\n    this.formFieldCallBack,\n  })  : assert(\n          items == null ||\n              items.isEmpty ||\n              value == null ||\n              items.where((DropdownMenuItem<T> item) {\n                    return item.value == value;\n                  }).length ==\n                  1,\n          \"There should be exactly one item with [DropdownButtonFormField]'s value: \"\n          '$value. \\n'\n          'Either zero or 2 or more [DropdownMenuItem]s were detected '\n          'with the same value',\n        ),\n        assert(\n          customItemsHeights == null ||\n              items == null ||\n              items.isEmpty ||\n              customItemsHeights.length == items.length,\n          \"customItemsHeights list should have the same length of items list\",\n        ),\n        assert(\n          (searchInnerWidget == null) == (searchInnerWidgetHeight == null),\n          \"searchInnerWidgetHeight should not be null when using searchInnerWidget\"\n          \"This is necessary to properly determine menu limits and scroll offset\",\n        );\n\n  // Parameters added By Me\n\n  /// The height of the button.\n  final double? buttonHeight;\n\n  /// The width of the button\n  final double? buttonWidth;\n\n  /// The inner padding of the Button\n  final EdgeInsetsGeometry? buttonPadding;\n\n  /// The decoration of the Button\n  final BoxDecoration? buttonDecoration;\n\n  /// The elevation of the Button\n  final int? buttonElevation;\n\n  /// The splash color of the button's InkWell\n  final Color? buttonSplashColor;\n\n  /// The highlight color of the button's InkWell\n  final Color? buttonHighlightColor;\n\n  /// The overlay color of the button's Inkwell\n  final MaterialStateProperty<Color?>? buttonOverlayColor;\n\n  /// The padding of menu items\n  final EdgeInsetsGeometry? itemPadding;\n\n  /// The splash color of the item's InkWell\n  final Color? itemSplashColor;\n\n  /// The highlight color of the item's InkWell\n  final Color? itemHighlightColor;\n\n  /// The width of the dropdown menu\n  final double? dropdownWidth;\n\n  /// The inner padding of the dropdown menu\n  final EdgeInsetsGeometry? dropdownPadding;\n\n  /// The inner padding of the dropdown menu including the scrollbar\n  final EdgeInsetsGeometry? dropdownScrollPadding;\n\n  /// The decoration of the dropdown menu\n  final BoxDecoration? dropdownDecoration;\n\n  /// The direction of the dropdown menu in relation to the button.\n  ///\n  /// Default is [DropdownDirection.textDirection]\n  final DropdownDirection dropdownDirection;\n\n  /// The highlight color of the current selected item\n  final Color? selectedItemHighlightColor;\n\n  /// The radius of the scrollbar's corners\n  final Radius? scrollbarRadius;\n\n  /// The thickness of the scrollbar\n  final double? scrollbarThickness;\n\n  /// Always show the scrollbar even when a scroll is not underway\n  final bool? scrollbarAlwaysShow;\n\n  /// Changes the position of the dropdown menu\n  final Offset? offset;\n\n  /// Uses custom widget like icon,image,etc.. instead of the default button\n  final Widget? customButton;\n\n  /// Uses different predefined heights for the menu items (useful for adding dividers)\n  final List<double>? customItemsHeights;\n\n  /// Opens the dropdown menu on long-pressing instead of tapping\n  final bool openWithLongPress;\n\n  /// Opens the dropdown menu over the button instead of below it\n  final bool dropdownOverButton;\n\n  /// Opens the dropdown menu in fullscreen mode (Above AppBar & TabBar)\n  final bool dropdownFullScreen;\n\n  /// Shows different icon when dropdown menu open\n  final Widget? iconOnClick;\n\n  /// Called when the dropdown menu is opened or closed.\n  final _OnMenuStateChangeFn? onMenuStateChange;\n\n  /// Whether you can dismiss this route by tapping the modal barrier.\n  final bool barrierDismissible;\n\n  /// The color to use for the modal barrier. If this is null, the barrier will\n  /// be transparent.\n  final Color? barrierColor;\n\n  /// The semantic label used for a dismissible barrier.\n  ///\n  /// If the barrier is dismissible, this label will be read out if\n  /// accessibility tools (like VoiceOver on iOS) focus on the barrier.\n  final String? barrierLabel;\n\n  /// The TextEditingController used for searchable dropdowns. If this is null,\n  /// then it'll perform as a normal dropdown without searching feature.\n  final TextEditingController? searchController;\n\n  /// The widget to use for searchable dropdowns, such as search bar.\n  /// It will be shown at the top of the dropdown menu.\n  final Widget? searchInnerWidget;\n\n  /// The height of the searchInnerWidget if used.\n  final double? searchInnerWidgetHeight;\n\n  /// The match function used for searchable dropdowns. If this is null,\n  /// then _defaultSearchMatchFn will be used.\n  ///\n  /// _defaultSearchMatchFn = (item, searchValue) =>\n  ///     item.value.toString().toLowerCase().contains(searchValue.toLowerCase());\n  final _SearchMatchFn<T>? searchMatchFn;\n\n  /// The list of items the user can select.\n  ///\n  /// If the [onChanged] callback is null or the list of items is null\n  /// then the dropdown button will be disabled, i.e. its arrow will be\n  /// displayed in grey and it will not respond to input.\n  final List<DropdownMenuItem<T>>? items;\n\n  /// The value of the currently selected [DropdownMenuItem].\n  ///\n  /// If [value] is null and the button is enabled, [hint] will be displayed\n  /// if it is non-null.\n  ///\n  /// If [value] is null and the button is disabled, [disabledHint] will be displayed\n  /// if it is non-null. If [disabledHint] is null, then [hint] will be displayed\n  /// if it is non-null.\n  final T? value;\n\n  /// A placeholder widget that is displayed by the dropdown button.\n  ///\n  /// If [value] is null and the dropdown is enabled ([items] and [onChanged] are non-null),\n  /// this widget is displayed as a placeholder for the dropdown button's value.\n  ///\n  /// If [value] is null and the dropdown is disabled and [disabledHint] is null,\n  /// this widget is used as the placeholder.\n  final Widget? hint;\n\n  /// A preferred placeholder widget that is displayed when the dropdown is disabled.\n  ///\n  /// If [value] is null, the dropdown is disabled ([items] or [onChanged] is null),\n  /// this widget is displayed as a placeholder for the dropdown button's value.\n  final Widget? disabledHint;\n\n  /// {@template flutter.material.dropdownButton.onChanged}\n  /// Called when the user selects an item.\n  ///\n  /// If the [onChanged] callback is null or the list of [DropdownButton2.items]\n  /// is null then the dropdown button will be disabled, i.e. its arrow will be\n  /// displayed in grey and it will not respond to input. A disabled button\n  /// will display the [DropdownButton2.disabledHint] widget if it is non-null.\n  /// If [DropdownButton2.disabledHint] is also null but [DropdownButton2.hint] is\n  /// non-null, [DropdownButton2.hint] will instead be displayed.\n  /// {@endtemplate}\n  final ValueChanged<T?>? onChanged;\n\n  /// A builder to customize the dropdown buttons corresponding to the\n  /// [DropdownMenuItem]s in [items].\n  ///\n  /// When a [DropdownMenuItem] is selected, the widget that will be displayed\n  /// from the list corresponds to the [DropdownMenuItem] of the same index\n  /// in [items].\n  ///\n  /// {@tool dartpad}\n  /// This sample shows a `DropdownButton` with a button with [Text] that\n  /// corresponds to but is unique from [DropdownMenuItem].\n  ///\n  /// ** See code in examples/api/lib/material/dropdown/dropdown_button.selected_item_builder.0.dart **\n  /// {@end-tool}\n  ///\n  /// If this callback is null, the [DropdownMenuItem] from [items]\n  /// that matches [value] will be displayed.\n  final DropdownButtonBuilder? selectedItemBuilder;\n\n  /// The z-coordinate at which to place the menu when open.\n  ///\n  /// The following elevations have defined shadows: 1, 2, 3, 4, 6, 8, 9, 12,\n  /// 16, and 24. See [kElevationToShadow].\n  ///\n  /// Defaults to 8, the appropriate elevation for dropdown buttons.\n  final int dropdownElevation;\n\n  /// The text style to use for text in the dropdown button and the dropdown\n  /// menu that appears when you tap the button.\n  ///\n  /// To use a separate text style for selected item when it's displayed within\n  /// the dropdown button, consider using [selectedItemBuilder].\n  ///\n  /// {@tool dartpad}\n  /// This sample shows a `DropdownButton` with a dropdown button text style\n  /// that is different than its menu items.\n  ///\n  /// ** See code in examples/api/lib/material/dropdown/dropdown_button.style.0.dart **\n  /// {@end-tool}\n  ///\n  /// Defaults to the [TextTheme.titleMedium] value of the current\n  /// [ThemeData.textTheme] of the current [Theme].\n  final TextStyle? style;\n\n  /// The widget to use for drawing the drop-down button's underline.\n  ///\n  /// Defaults to a 0.0 width bottom border with color 0xFFBDBDBD.\n  final Widget? underline;\n\n  /// The widget to use for the drop-down button's icon.\n  ///\n  /// Defaults to an [Icon] with the [Icons.arrow_drop_down] glyph.\n  final Widget? icon;\n\n  /// The color of any [Icon] descendant of [icon] if this button is disabled,\n  /// i.e. if [onChanged] is null.\n  ///\n  /// Defaults to [MaterialColor.shade400] of [Colors.grey] when the theme's\n  /// [ThemeData.brightness] is [Brightness.light] and to\n  /// [Colors.white10] when it is [Brightness.dark]\n  final Color? iconDisabledColor;\n\n  /// The color of any [Icon] descendant of [icon] if this button is enabled,\n  /// i.e. if [onChanged] is defined.\n  ///\n  /// Defaults to [MaterialColor.shade700] of [Colors.grey] when the theme's\n  /// [ThemeData.brightness] is [Brightness.light] and to\n  /// [Colors.white70] when it is [Brightness.dark]\n  final Color? iconEnabledColor;\n\n  /// The size to use for the drop-down button's icon.\n  ///\n  /// Defaults to 24.0.\n  final double iconSize;\n\n  /// Reduce the button's height.\n  ///\n  /// By default this button's height is the same as its menu items' heights.\n  /// If isDense is true, the button's height is reduced by about half. This\n  /// can be useful when the button is embedded in a container that adds\n  /// its own decorations, like [InputDecorator].\n  final bool isDense;\n\n  /// Set the dropdown's inner contents to horizontally fill its parent.\n  ///\n  /// By default this button's inner width is the minimum size of its contents.\n  /// If [isExpanded] is true, the inner width is expanded to fill its\n  /// surrounding container.\n  final bool isExpanded;\n\n  /// The default value is [kMinInteractiveDimension]\n  final double itemHeight;\n\n  /// The color for the button's [Material] when it has the input focus.\n  final Color? focusColor;\n\n  /// {@macro flutter.widgets.Focus.focusNode}\n  final FocusNode? focusNode;\n\n  /// {@macro flutter.widgets.Focus.autofocus}\n  final bool autofocus;\n\n  /// The maximum height of the menu.\n  ///\n  /// The maximum height of the menu must be at least one row shorter than\n  /// the height of the app's view. This ensures that a tappable area\n  /// outside of the simple menu is present so the user can dismiss the menu.\n  ///\n  /// If this property is set above the maximum allowable height threshold\n  /// mentioned above, then the menu defaults to being padded at the top\n  /// and bottom of the menu by at one menu item's height.\n  final double? dropdownMaxHeight;\n\n  /// Whether detected gestures should provide acoustic and/or haptic feedback.\n  ///\n  /// For example, on Android a tap will produce a clicking sound and a\n  /// long-press will produce a short vibration, when feedback is enabled.\n  ///\n  /// By default, platform-specific feedback is enabled.\n  ///\n  /// See also:\n  ///\n  ///  * [Feedback] for providing platform-specific feedback to certain actions.\n  final bool? enableFeedback;\n\n  /// Defines how the hint or the selected item is positioned within the button.\n  ///\n  /// This property must not be null. It defaults to [AlignmentDirectional.centerStart].\n  ///\n  /// See also:\n  ///\n  ///  * [Alignment], a class with convenient constants typically used to\n  ///    specify an [AlignmentGeometry].\n  ///  * [AlignmentDirectional], like [Alignment] for specifying alignments\n  ///    relative to text direction.\n  final AlignmentGeometry alignment;\n\n  /// Called when the dropdown menu is opened or closed in case of using\n  /// DropdownButtonFormField2 to update the FormField's focus.\n  final _OnMenuStateChangeFn? formFieldCallBack;\n\n  @override\n  State<DropdownButton2<T>> createState() => DropdownButton2State<T>();\n}\n\nclass DropdownButton2State<T> extends State<DropdownButton2<T>>\n    with WidgetsBindingObserver {\n  int? _selectedIndex;\n  _DropdownRoute<T>? _dropdownRoute;\n  Orientation? _lastOrientation;\n  FocusNode? _internalNode;\n\n  FocusNode? get focusNode => widget.focusNode ?? _internalNode;\n  bool _hasPrimaryFocus = false;\n  late Map<Type, Action<Intent>> _actionMap;\n  bool _isMenuOpen = false;\n\n  // Using ValueNotifier for the Rect of DropdownButton so the dropdown menu listen and\n  // update its position if DropdownButton's position has changed, as when keyboard open.\n  final _rect = ValueNotifier<Rect?>(null);\n\n  // Only used if needed to create _internalNode.\n  FocusNode _createFocusNode() {\n    return FocusNode(debugLabel: '${widget.runtimeType}');\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    WidgetsBinding.instance.addObserver(this);\n    _updateSelectedIndex();\n    if (widget.focusNode == null) {\n      _internalNode ??= _createFocusNode();\n    }\n    _actionMap = <Type, Action<Intent>>{\n      ActivateIntent: CallbackAction<ActivateIntent>(\n        onInvoke: (ActivateIntent intent) => _handleTap(),\n      ),\n      ButtonActivateIntent: CallbackAction<ButtonActivateIntent>(\n        onInvoke: (ButtonActivateIntent intent) => _handleTap(),\n      ),\n    };\n    focusNode!.addListener(_handleFocusChanged);\n  }\n\n  @override\n  void dispose() {\n    WidgetsBinding.instance.removeObserver(this);\n    _removeDropdownRoute();\n    focusNode!.removeListener(_handleFocusChanged);\n    _internalNode?.dispose();\n    super.dispose();\n  }\n\n  void _removeDropdownRoute() {\n    _dropdownRoute?._dismiss();\n    _dropdownRoute = null;\n    _lastOrientation = null;\n  }\n\n  void _handleFocusChanged() {\n    if (_hasPrimaryFocus != focusNode!.hasPrimaryFocus) {\n      setState(() {\n        _hasPrimaryFocus = focusNode!.hasPrimaryFocus;\n      });\n    }\n  }\n\n  @override\n  void didUpdateWidget(DropdownButton2<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (widget.focusNode != oldWidget.focusNode) {\n      oldWidget.focusNode?.removeListener(_handleFocusChanged);\n      if (widget.focusNode == null) {\n        _internalNode ??= _createFocusNode();\n      }\n      _hasPrimaryFocus = focusNode!.hasPrimaryFocus;\n      focusNode!.addListener(_handleFocusChanged);\n    }\n    _updateSelectedIndex();\n  }\n\n  void _updateSelectedIndex() {\n    if (widget.items == null ||\n        widget.items!.isEmpty ||\n        (widget.value == null &&\n            widget.items!\n                .where((DropdownMenuItem<T> item) =>\n                    item.enabled && item.value == widget.value)\n                .isEmpty)) {\n      _selectedIndex = null;\n      return;\n    }\n\n    assert(widget.items!\n            .where((DropdownMenuItem<T> item) => item.value == widget.value)\n            .length ==\n        1);\n    for (int itemIndex = 0; itemIndex < widget.items!.length; itemIndex++) {\n      if (widget.items![itemIndex].value == widget.value) {\n        _selectedIndex = itemIndex;\n        return;\n      }\n    }\n  }\n\n  @override\n  void didChangeMetrics() {\n    //This fix the bug of calling didChangeMetrics() on iOS when app starts\n    if (_rect.value == null) return;\n    final _newRect = _getRect();\n    //This avoid unnecessary rebuilds if _rect position hasn't changed\n    if (_rect.value!.top == _newRect.top) return;\n    _rect.value = _newRect;\n  }\n\n  TextStyle? get _textStyle =>\n      widget.style ?? Theme.of(context).textTheme.titleMedium;\n\n  Rect _getRect() {\n    final TextDirection? textDirection = Directionality.maybeOf(context);\n    const EdgeInsetsGeometry menuMargin = EdgeInsets.zero;\n    final NavigatorState navigator =\n        Navigator.of(context, rootNavigator: widget.dropdownFullScreen);\n\n    final RenderBox itemBox = context.findRenderObject()! as RenderBox;\n    final Rect itemRect = itemBox.localToGlobal(Offset.zero,\n            ancestor: navigator.context.findRenderObject()) &\n        itemBox.size;\n\n    return menuMargin.resolve(textDirection).inflateRect(itemRect);\n  }\n\n  double _getMenuHorizontalPadding() {\n    final menuHorizontalPadding =\n        (widget.itemPadding?.horizontal ?? _kMenuItemPadding.horizontal) +\n            (widget.dropdownPadding?.horizontal ?? 0.0) +\n            (widget.dropdownScrollPadding?.horizontal ?? 0.0);\n    return menuHorizontalPadding / 2;\n  }\n\n  void _handleTap() {\n    final TextDirection? textDirection = Directionality.maybeOf(context);\n\n    final List<_MenuItem<T>> menuItems = <_MenuItem<T>>[\n      for (int index = 0; index < widget.items!.length; index += 1)\n        _MenuItem<T>(\n          item: widget.items![index],\n          onLayout: (Size size) {\n            // If [_dropdownRoute] is null and onLayout is called, this means\n            // that performLayout was called on a _DropdownRoute that has not\n            // left the widget tree but is already on its way out.\n            //\n            // Since onLayout is used primarily to collect the desired heights\n            // of each menu item before laying them out, not having the _DropdownRoute\n            // collect each item's height to lay out is fine since the route is\n            // already on its way out.\n            if (_dropdownRoute == null) return;\n\n            _dropdownRoute!.itemHeights[index] = size.height;\n          },\n        ),\n    ];\n\n    final NavigatorState navigator =\n        Navigator.of(context, rootNavigator: widget.dropdownFullScreen);\n    assert(_dropdownRoute == null);\n    _rect.value = _getRect();\n    _dropdownRoute = _DropdownRoute<T>(\n      items: menuItems,\n      buttonRect: _rect,\n      padding: widget.itemPadding ?? _kMenuItemPadding.resolve(textDirection),\n      selectedIndex: _selectedIndex ?? 0,\n      isNoSelectedItem: _selectedIndex == null,\n      selectedItemHighlightColor: widget.selectedItemHighlightColor,\n      elevation: widget.dropdownElevation,\n      capturedThemes:\n          InheritedTheme.capture(from: context, to: navigator.context),\n      style: _textStyle!,\n      barrierDismissible: widget.barrierDismissible,\n      barrierColor: widget.barrierColor,\n      barrierLabel: widget.barrierLabel ??\n          MaterialLocalizations.of(context).modalBarrierDismissLabel,\n      enableFeedback: widget.enableFeedback ?? true,\n      itemHeight: widget.itemHeight,\n      itemWidth: widget.dropdownWidth,\n      menuMaxHeight: widget.dropdownMaxHeight,\n      dropdownPadding: widget.dropdownPadding,\n      dropdownScrollPadding: widget.dropdownScrollPadding,\n      dropdownDecoration: widget.dropdownDecoration,\n      dropdownDirection: widget.dropdownDirection,\n      scrollbarRadius: widget.scrollbarRadius,\n      scrollbarThickness: widget.scrollbarThickness,\n      scrollbarAlwaysShow: widget.scrollbarAlwaysShow,\n      offset: widget.offset ?? const Offset(0, 0),\n      showAboveButton: widget.dropdownOverButton,\n      itemSplashColor: widget.itemSplashColor,\n      itemHighlightColor: widget.itemHighlightColor,\n      customItemsHeights: widget.customItemsHeights,\n      searchController: widget.searchController,\n      searchInnerWidget: widget.searchInnerWidget,\n      searchInnerWidgetHeight: widget.searchInnerWidgetHeight,\n      searchMatchFn: widget.searchMatchFn,\n    );\n\n    _isMenuOpen = true;\n    focusNode?.requestFocus();\n    navigator\n        .push(_dropdownRoute!)\n        .then<void>((_DropdownRouteResult<T>? newValue) {\n      _removeDropdownRoute();\n      _isMenuOpen = false;\n      widget.onMenuStateChange?.call(false);\n      widget.formFieldCallBack?.call(false);\n      if (!mounted || newValue == null) return;\n      widget.onChanged?.call(newValue.result);\n    });\n\n    widget.onMenuStateChange?.call(true);\n    widget.formFieldCallBack?.call(true);\n  }\n\n  // This expose the _handleTap() to Allow opening the button programmatically using GlobalKey.\n  // Also, DropdownButton2State should be public as we need typed access to it through key.\n  void callTap() => _handleTap();\n\n  // When isDense is true, reduce the height of this button from _kMenuItemHeight to\n  // _kDenseButtonHeight, but don't make it smaller than the text that it contains.\n  // Similarly, we don't reduce the height of the button so much that its icon\n  // would be clipped.\n  double get _denseButtonHeight {\n    final double textScaleFactor = MediaQuery.of(context).textScaleFactor;\n    final double fontSize = _textStyle!.fontSize ??\n        Theme.of(context).textTheme.titleMedium!.fontSize!;\n    final double scaledFontSize = textScaleFactor * fontSize;\n    return math.max(\n        scaledFontSize, math.max(widget.iconSize, _kDenseButtonHeight));\n  }\n\n  Color get _iconColor {\n    // These colors are not defined in the Material Design spec.\n    if (_enabled) {\n      if (widget.iconEnabledColor != null) return widget.iconEnabledColor!;\n\n      switch (Theme.of(context).brightness) {\n        case Brightness.light:\n          return Colors.grey.shade700;\n        case Brightness.dark:\n          return Colors.white70;\n      }\n    } else {\n      if (widget.iconDisabledColor != null) return widget.iconDisabledColor!;\n\n      switch (Theme.of(context).brightness) {\n        case Brightness.light:\n          return Colors.grey.shade400;\n        case Brightness.dark:\n          return Colors.white10;\n      }\n    }\n  }\n\n  bool get _enabled =>\n      widget.items != null &&\n      widget.items!.isNotEmpty &&\n      widget.onChanged != null;\n\n  Orientation _getOrientation(BuildContext context) {\n    Orientation? result = MediaQuery.maybeOf(context)?.orientation;\n    if (result == null) {\n      // If there's no MediaQuery, then use the window aspect to determine\n      // orientation.\n      final Size size = WidgetsBinding.instance.window.physicalSize;\n      result = size.width > size.height\n          ? Orientation.landscape\n          : Orientation.portrait;\n    }\n    return result;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    assert(debugCheckHasMaterial(context));\n    assert(debugCheckHasMaterialLocalizations(context));\n    final Orientation newOrientation = _getOrientation(context);\n    _lastOrientation ??= newOrientation;\n    if (newOrientation != _lastOrientation) {\n      _removeDropdownRoute();\n      _lastOrientation = newOrientation;\n    }\n\n    // The width of the button and the menu are defined by the widest\n    // item and the width of the hint.\n    // We should explicitly type the items list to be a list of <Widget>,\n    // otherwise, no explicit type adding items maybe trigger a crash/failure\n    // when hint and selectedItemBuilder are provided.\n    final List<Widget> items = widget.selectedItemBuilder == null\n        ? (widget.items != null ? List<Widget>.of(widget.items!) : <Widget>[])\n        : List<Widget>.of(widget.selectedItemBuilder!(context));\n\n    int? hintIndex;\n    if (widget.hint != null || (!_enabled && widget.disabledHint != null)) {\n      final Widget displayedHint =\n          _enabled ? widget.hint! : widget.disabledHint ?? widget.hint!;\n\n      hintIndex = items.length;\n      items.add(DefaultTextStyle(\n        style: _textStyle!.copyWith(color: Theme.of(context).hintColor),\n        child: IgnorePointer(\n          ignoringSemantics: false,\n          child: _DropdownMenuItemContainer(\n            alignment: widget.alignment,\n            child: displayedHint,\n          ),\n        ),\n      ));\n    }\n\n    final EdgeInsetsGeometry padding = ButtonTheme.of(context).alignedDropdown\n        ? _kAlignedButtonPadding\n        : _kUnalignedButtonPadding;\n\n    // If value is null (then _selectedIndex is null) then we\n    // display the hint or nothing at all.\n    final Widget innerItemsWidget;\n    if (items.isEmpty) {\n      innerItemsWidget = const SizedBox.shrink();\n    } else {\n      innerItemsWidget = Padding(\n        //When buttonWidth & dropdownWidth is null, their width will be calculated\n        //from the maximum width of menu items or the hint text (width of IndexedStack).\n        //We need to add MenuHorizontalPadding so menu width adapts to max items width with padding properly\n        padding: EdgeInsets.symmetric(\n          horizontal: widget.buttonWidth == null && widget.dropdownWidth == null\n              ? _getMenuHorizontalPadding()\n              : 0.0,\n        ),\n        child: IndexedStack(\n          index: _selectedIndex ?? hintIndex,\n          alignment: widget.alignment,\n          children: widget.isDense\n              ? items\n              : items.map((Widget item) {\n                  return SizedBox(height: widget.itemHeight, child: item);\n                }).toList(),\n        ),\n      );\n    }\n\n    const Icon defaultIcon = Icon(Icons.arrow_drop_down);\n\n    Widget result = DefaultTextStyle(\n      style: _enabled\n          ? _textStyle!\n          : _textStyle!.copyWith(color: Theme.of(context).disabledColor),\n      child: widget.customButton ??\n          Container(\n            decoration: widget.buttonDecoration?.copyWith(\n              boxShadow: widget.buttonDecoration!.boxShadow ??\n                  kElevationToShadow[widget.buttonElevation ?? 0],\n            ),\n            padding: widget.buttonPadding ??\n                padding.resolve(Directionality.of(context)),\n            height: widget.buttonHeight ??\n                (widget.isDense ? _denseButtonHeight : null),\n            width: widget.buttonWidth,\n            child: Row(\n              mainAxisAlignment: MainAxisAlignment.spaceBetween,\n              mainAxisSize: MainAxisSize.min,\n              children: <Widget>[\n                if (widget.isExpanded)\n                  Expanded(child: innerItemsWidget)\n                else\n                  innerItemsWidget,\n                IconTheme(\n                  data: IconThemeData(\n                    color: _iconColor,\n                    size: widget.iconSize,\n                  ),\n                  child: widget.iconOnClick != null\n                      ? _isMenuOpen\n                          ? widget.iconOnClick!\n                          : widget.icon!\n                      : widget.icon ?? defaultIcon,\n                ),\n              ],\n            ),\n          ),\n    );\n\n    if (!DropdownButtonHideUnderline.at(context)) {\n      final double bottom = widget.isDense ? 0.0 : 8.0;\n      result = Stack(\n        children: <Widget>[\n          result,\n          Positioned(\n            left: 0.0,\n            right: 0.0,\n            bottom: bottom,\n            child: widget.underline ??\n                Container(\n                  height: 1.0,\n                  decoration: const BoxDecoration(\n                    border: Border(\n                      bottom: BorderSide(\n                        color: Color(0xFFBDBDBD),\n                        width: 0.0,\n                      ),\n                    ),\n                  ),\n                ),\n          ),\n        ],\n      );\n    }\n\n    final MouseCursor effectiveMouseCursor =\n        MaterialStateProperty.resolveAs<MouseCursor>(\n      MaterialStateMouseCursor.clickable,\n      <MaterialState>{\n        if (!_enabled) MaterialState.disabled,\n      },\n    );\n\n    return Semantics(\n      button: true,\n      child: Actions(\n        actions: _actionMap,\n        child: InkWell(\n          mouseCursor: effectiveMouseCursor,\n          onTap: _enabled && !widget.openWithLongPress ? _handleTap : null,\n          onLongPress: _enabled && widget.openWithLongPress ? _handleTap : null,\n          canRequestFocus: _enabled,\n          focusNode: focusNode,\n          autofocus: widget.autofocus,\n          focusColor: widget.buttonDecoration?.color ??\n              widget.focusColor ??\n              Theme.of(context).focusColor,\n          splashColor: widget.buttonSplashColor,\n          highlightColor: widget.buttonHighlightColor,\n          overlayColor: widget.buttonOverlayColor,\n          enableFeedback: false,\n          child: result,\n          borderRadius: widget.buttonDecoration?.borderRadius\n              ?.resolve(Directionality.of(context)),\n        ),\n      ),\n    );\n  }\n}\n\n/// A [FormField] that contains a [DropdownButton2].\n///\n/// This is a convenience widget that wraps a [DropdownButton2] widget in a\n/// [FormField].\n///\n/// A [Form] ancestor is not required. The [Form] simply makes it easier to\n/// save, reset, or validate multiple fields at once. To use without a [Form],\n/// pass a [GlobalKey] to the constructor and use [GlobalKey.currentState] to\n/// save or reset the form field.\n///\n/// See also:\n///\n///  * [DropdownButton2], which is the underlying text field without the [Form]\n///    integration.\nclass DropdownButtonFormField2<T> extends FormField<T> {\n  /// Creates a [DropdownButton2] widget that is a [FormField], wrapped in an\n  /// [InputDecorator].\n  ///\n  /// For a description of the `onSaved`, `validator`, or `autovalidateMode`\n  /// parameters, see [FormField]. For the rest (other than [decoration]), see\n  /// [DropdownButton2].\n  ///\n  /// The `items`, `elevation`, `iconSize`, `isDense`, `isExpanded`,\n  /// `autofocus`, and `decoration`  parameters must not be null.\n  DropdownButtonFormField2({\n    super.key,\n    this.dropdownButtonKey,\n    required List<DropdownMenuItem<T>>? items,\n    DropdownButtonBuilder? selectedItemBuilder,\n    T? value,\n    Widget? hint,\n    Widget? disabledHint,\n    this.onChanged,\n    int dropdownElevation = 8,\n    TextStyle? style,\n    Widget? icon,\n    Widget? iconOnClick,\n    Color? iconDisabledColor,\n    Color? iconEnabledColor,\n    double iconSize = 24.0,\n    bool isDense = true,\n    bool isExpanded = false,\n    double itemHeight = kMinInteractiveDimension,\n    Color? focusColor,\n    FocusNode? focusNode,\n    bool autofocus = false,\n    InputDecoration? decoration,\n    super.onSaved,\n    super.validator,\n    AutovalidateMode? autovalidateMode,\n    double? dropdownMaxHeight,\n    bool? enableFeedback,\n    AlignmentGeometry alignment = AlignmentDirectional.centerStart,\n    double? buttonHeight,\n    double? buttonWidth,\n    EdgeInsetsGeometry? buttonPadding,\n    BoxDecoration? buttonDecoration,\n    int? buttonElevation,\n    Color? buttonSplashColor,\n    Color? buttonHighlightColor,\n    MaterialStateProperty<Color?>? buttonOverlayColor,\n    EdgeInsetsGeometry? itemPadding,\n    Color? itemSplashColor,\n    Color? itemHighlightColor,\n    double? dropdownWidth,\n    EdgeInsetsGeometry? dropdownPadding,\n    EdgeInsetsGeometry? dropdownScrollPadding,\n    BoxDecoration? dropdownDecoration,\n    DropdownDirection dropdownDirection = DropdownDirection.textDirection,\n    Color? selectedItemHighlightColor,\n    Radius? scrollbarRadius,\n    double? scrollbarThickness,\n    bool? scrollbarAlwaysShow,\n    Offset? offset,\n    Widget? customButton,\n    List<double>? customItemsHeights,\n    bool openWithLongPress = false,\n    bool dropdownOverButton = false,\n    bool dropdownFullScreen = false,\n    bool barrierDismissible = true,\n    Color? barrierColor,\n    String? barrierLabel,\n    TextEditingController? searchController,\n    Widget? searchInnerWidget,\n    double? searchInnerWidgetHeight,\n    _SearchMatchFn? searchMatchFn,\n    _OnMenuStateChangeFn? onMenuStateChange,\n  })  : assert(\n          items == null ||\n              items.isEmpty ||\n              value == null ||\n              items.where((DropdownMenuItem<T> item) {\n                    return item.value == value;\n                  }).length ==\n                  1,\n          \"There should be exactly one item with [DropdownButton]'s value: \"\n          '$value. \\n'\n          'Either zero or 2 or more [DropdownMenuItem]s were detected '\n          'with the same value',\n        ),\n        decoration = decoration ?? InputDecoration(focusColor: focusColor),\n        super(\n          initialValue: value,\n          autovalidateMode: autovalidateMode ?? AutovalidateMode.disabled,\n          builder: (FormFieldState<T> field) {\n            final _DropdownButtonFormFieldState<T> state =\n                field as _DropdownButtonFormFieldState<T>;\n            final InputDecoration decorationArg =\n                decoration ?? InputDecoration(focusColor: focusColor);\n            final InputDecoration effectiveDecoration =\n                decorationArg.applyDefaults(\n              Theme.of(field.context).inputDecorationTheme,\n            );\n\n            final bool showSelectedItem = items != null &&\n                items\n                    .where(\n                        (DropdownMenuItem<T> item) => item.value == state.value)\n                    .isNotEmpty;\n            bool isHintOrDisabledHintAvailable() {\n              final bool isDropdownDisabled =\n                  onChanged == null || (items == null || items.isEmpty);\n              if (isDropdownDisabled) {\n                return hint != null || disabledHint != null;\n              } else {\n                return hint != null;\n              }\n            }\n\n            final bool isEmpty =\n                !showSelectedItem && !isHintOrDisabledHintAvailable();\n\n            bool hasFocus = false;\n\n            // An unFocusable Focus widget so that this widget can detect if its\n            // descendants have focus or not.\n            return Focus(\n              canRequestFocus: false,\n              skipTraversal: true,\n              child: StatefulBuilder(\n                builder: (BuildContext context, StateSetter setState) {\n                  return InputDecorator(\n                    decoration: effectiveDecoration.copyWith(\n                        errorText: field.errorText),\n                    isEmpty: isEmpty,\n                    isFocused: hasFocus,\n                    textAlignVertical: TextAlignVertical.bottom,\n                    child: DropdownButtonHideUnderline(\n                      child: DropdownButton2._formField(\n                        key: dropdownButtonKey,\n                        items: items,\n                        selectedItemBuilder: selectedItemBuilder,\n                        value: state.value,\n                        hint: hint,\n                        disabledHint: disabledHint,\n                        onChanged: onChanged == null ? null : state.didChange,\n                        dropdownElevation: dropdownElevation,\n                        style: style,\n                        icon: icon,\n                        iconOnClick: iconOnClick,\n                        iconDisabledColor: iconDisabledColor,\n                        iconEnabledColor: iconEnabledColor,\n                        iconSize: iconSize,\n                        isDense: isDense,\n                        isExpanded: isExpanded,\n                        itemHeight: itemHeight,\n                        focusColor: focusColor,\n                        focusNode: focusNode,\n                        autofocus: autofocus,\n                        dropdownMaxHeight: dropdownMaxHeight,\n                        enableFeedback: enableFeedback,\n                        alignment: alignment,\n                        buttonHeight: buttonHeight,\n                        buttonWidth: buttonWidth,\n                        buttonPadding: buttonPadding,\n                        buttonDecoration: buttonDecoration,\n                        buttonElevation: buttonElevation,\n                        buttonSplashColor: buttonSplashColor,\n                        buttonHighlightColor: buttonHighlightColor,\n                        buttonOverlayColor: buttonOverlayColor,\n                        itemPadding: itemPadding,\n                        itemSplashColor: itemSplashColor,\n                        itemHighlightColor: itemHighlightColor,\n                        dropdownWidth: dropdownWidth,\n                        dropdownPadding: dropdownPadding,\n                        dropdownScrollPadding: dropdownScrollPadding,\n                        dropdownDecoration: dropdownDecoration,\n                        dropdownDirection: dropdownDirection,\n                        selectedItemHighlightColor: selectedItemHighlightColor,\n                        scrollbarRadius: scrollbarRadius,\n                        scrollbarThickness: scrollbarThickness,\n                        scrollbarAlwaysShow: scrollbarAlwaysShow,\n                        offset: offset,\n                        customButton: customButton,\n                        customItemsHeights: customItemsHeights,\n                        openWithLongPress: openWithLongPress,\n                        dropdownOverButton: dropdownOverButton,\n                        dropdownFullScreen: dropdownFullScreen,\n                        onMenuStateChange: onMenuStateChange,\n                        barrierDismissible: barrierDismissible,\n                        barrierColor: barrierColor,\n                        barrierLabel: barrierLabel,\n                        searchController: searchController,\n                        searchInnerWidget: searchInnerWidget,\n                        searchInnerWidgetHeight: searchInnerWidgetHeight,\n                        searchMatchFn: searchMatchFn,\n                        formFieldCallBack: (isOpen) {\n                          hasFocus = isOpen;\n                          setState(() {});\n                        },\n                      ),\n                    ),\n                  );\n                },\n              ),\n            );\n          },\n        );\n\n  /// The key of DropdownButton2 child widget\n  ///\n  /// This allows accessing DropdownButton2State.\n  /// It is useful for some cases, i.e: calling callTap() method to open the menu programmatically\n  final Key? dropdownButtonKey;\n\n  /// {@macro flutter.material.dropdownButton.onChanged}\n  final ValueChanged<T?>? onChanged;\n\n  /// The decoration to show around the dropdown button form field.\n  ///\n  /// By default, draws a horizontal line under the dropdown button field but\n  /// can be configured to show an icon, label, hint text, and error text.\n  ///\n  /// If not specified, an [InputDecorator] with the `focusColor` set to the\n  /// supplied `focusColor` (if any) will be used.\n  final InputDecoration decoration;\n\n  @override\n  FormFieldState<T> createState() => _DropdownButtonFormFieldState<T>();\n}\n\nclass _DropdownButtonFormFieldState<T> extends FormFieldState<T> {\n  @override\n  void didChange(T? value) {\n    super.didChange(value);\n    final DropdownButtonFormField2<T> dropdownButtonFormField =\n        widget as DropdownButtonFormField2<T>;\n    assert(dropdownButtonFormField.onChanged != null);\n    dropdownButtonFormField.onChanged!(value);\n  }\n\n  @override\n  void didUpdateWidget(DropdownButtonFormField2<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.initialValue != widget.initialValue) {\n      setValue(widget.initialValue);\n    }\n  }\n}\n"
        }
    ]
}